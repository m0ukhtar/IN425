def run(self):
    if not self.reached and self.goal_received:
        self.get_robot_pose()
        if self.inc >= len(self.path):
            self.reached = True
            self.linear = 0.0
            self.angular = 0.0
            self.send_velocities()
            return

        current_goal = self.path[self.inc].pose.position

        dx = current_goal.x - self.robot_pose.x
        dy = current_goal.y - self.robot_pose.y

        rho = math.sqrt(dx ** 2 + dy ** 2)
        angle_to_goal = math.atan2(dy, dx)
        alpha = self.normalize_angle(angle_to_goal - self.robot_pose.theta)

        k_rho = 0.8   # Réduit pour moins d'agressivité
        k_alpha = 1.5 # Augmenté pour une correction plus rapide

        if abs(alpha) > 0.1:  # Seuil réduit pour plus de fluidité
            self.linear = min(0.3, k_rho * rho)  # Mouvement linéaire réduit
            self.angular = 2.0 * alpha
        else:
            self.linear = min(1.0, k_rho * rho)
            self.angular = k_alpha * alpha

        if rho < 0.15:
            self.inc += 1

        self.send_velocities()
        self.publish_path()
