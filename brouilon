def smooth_path(self, path, iterations=5):  # Increased iterations from 3 to 5
    # Chaikin's algorithm for curve smoothing
    for _ in range(iterations):
        new_path = [path[0]]
        for i in range(len(path) - 1):
            p0 = np.array(path[i])
            p1 = np.array(path[i + 1])
            Q = 0.75 * p0 + 0.25 * p1
            R = 0.25 * p0 + 0.75 * p1
            new_path.append(tuple(Q.astype(int)))
            new_path.append(tuple(R.astype(int)))
        new_path.append(path[-1])
        path = new_path
    # Supprime les points trop proches pour éviter le sur-échantillonnage
    filtered = [path[0]]
    for p in path[1:]:
        if np.linalg.norm(np.array(p) - np.array(filtered[-1])) > 1:  # Reduced from 2 to 1 for denser points
            filtered.append(p)
    return filtered
